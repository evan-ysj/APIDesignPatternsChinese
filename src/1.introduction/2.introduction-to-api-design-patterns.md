# 第二章 什么是API设计模式

> 本章涵盖：
> - 什么是API设计模式
> - 为什么API设计模式很重要
> - 解构API设计模式
> - 使用设计模式和不使用设计模式来设计API的差异

现在，我们已经了解了API是什么以及什么是“好”的API，我们可以继续探讨在构建API时如何应用不同的模式。我们将从探讨API设计模式是什么，为什么它们很重要，以及我们将如何在后续章节中解析这些模式。最后，我们将查看一个示例API，看看如何使用预构建的API设计模式可以节省大量时间和避免潜在的麻烦。

## 什么是API设计模式

在我们开始探讨API设计模式之前，我们需要打下一些基础。首先从一个简单的问题开始：什么是设计模式？如果我们注意到软件设计是指为了解决问题而编写的一些代码的结构或布局，那么软件设计模式是指特定的设计可以反复应用于许多类似的软件问题，只需要进行小的调整以适应不同的情境。这意味着该模式不是我们用来解决单个问题的预构建库，而更像是解决相似结构问题的蓝图。

如果这听起来太抽象，让我们来具体化一下，想象一下我们想在后院建一个小屋。有几种不同的选择，从几百年前的做法到如今由Lowe's和Home Depot等公司提供的现代化专业方法。有很多选择，但有四种常见的选择，如下所示：

1. 购买预制的小屋并放在后院。
2. 购买小屋套件（设计图纸和材料）并自己组装。
3. 购买一套小屋的设计图，根据需要修改设计，然后自己建造。
4. 从头开始设计和建造整个小屋。

如果我们将这些与它们的软件等效物联系起来，它们将从使用现成的现成软件包一直到编写完全定制的系统来解决问题。在表2.1中，我们可以看到随着列表项目从上到下，这些选项会变得越来越困难，但从一个选项到下一个会增加越来越多的灵活性。换句话说，难度最低的灵活性最小，而难度最大的灵活性最大。

<small>表2.1 建造小屋和构建软件系统方式的类比</small>

| 选项 | 困难度 | 灵活度 | 对应的软件构件选项 |
| --- | --- | --- | --- |
| 购买预制的小屋 | 简单 | 无 | 直接使用现成的软件包 |
| 购买套件组装 | 比较简单 | 很小 | 自定义现成的软件包 |
| 按照现成设计图建造 | 一般 | 一般 | 从设计文档开始构建 |
| 从头设计并建造 | 困难 | 最大 | 从头设计软件系统并构建 |

软件工程师大多数情况下倾向于选择“从头开始构建”的选项。有时这是必要的，特别是在我们解决的问题是新问题的情况下。其他情况下，这个选择在成本效益分析中胜出，因为我们的问题与易用选项有足够的不同。还有一些情况下，我们可能已经知道一个库恰好解决了我们的问题（或者足够接近），因此我们选择依赖已经解决类似问题的工具。事实证明，选择介于中间的选项（定制现有软件或根据设计文档进行构建）不太常见，但却应该经常使用并会获得很好的效果。这就是设计模式的应用之处。

从上层看，设计模式是应用于软件的“按设计图纸构建”的选项。就像小屋的设计图包括尺寸、门窗的位置以及屋顶的材料一样，设计模式包括我们编写的代码的某些规格和细节。在软件中，这通常意味着指定代码的高级布局以及依赖布局来解决特定设计问题的细微差别。然而，很少有设计模式是为了完全独立使用而生的。大多数情况下，设计模式侧重于特定的组件而不是整个系统。换句话说，设计图侧重于单个方面（比如屋顶形状）或组件（比如窗户设计），而不是整个小屋。乍看之下，这可能看起来不太好，但只有在目标确实是建造一个小屋的情况下才是如此。如果您尝试构建与小屋类似但不完全相同的东西，那么拥有每个单独组件的设计图意味着您可以将它们组合在一起，精确地构建出您想要的东西，选择屋顶形状A和窗户设计B。这也适用于我们的设计模式讨论，因为每个设计模式通常侧重于系统的单个组件或问题类型，通过组装许多预设计的组件，帮助您构建出您想要的东西。

例如，如果您想要向系统添加调试日志记录，您可能只希望有一种方法来记录消息。有很多方法可以做到这一点（例如，使用一个单一的全局变量），但偶然间有一个设计模式旨在解决这个软件问题。这个模式在经典著作《设计模式》（Gamma等人，1994）中有所描述，被称为单例模式（singleton），它确保只创建一个类的实例。这个“设计图”要求一个类具有私有构造函数和一个名为`getInstance()`的静态方法，该方法总是返回该类的单个实例（只有在它还不存在的情况下才创建该单个实例）。这个模式本身不是全部（毕竟，拥有一个什么都不做的单例类有什么用呢？）；但是，它是在需要解决这个小型问题的情况下要遵循的一个经过明确定义和经过充分测试的模式，即始终有一个类的单个实例。

现在我们知道了通常的软件设计模式是什么，我们必须问一个问题：什么是API设计模式？根据第1章中对API的描述，API设计模式只是将软件设计模式应用于API而不是所有软件。这意味着API设计模式与普通设计模式一样，只是用于设计和构建API的方法的蓝图。由于重点是接口而不是实现，在大多数情况下，API设计模式将专注于接口，而不一定会构建实现。虽然大多数API设计模式通常不会详细说明这些接口的底层实现，但有时它们会规定API行为的某些方面。例如，一个API设计模式可能会指定某个RPC可以是最终一致的（eventually consistent），这意味着从该RPC返回的数据可能会略有过时（例如，它可能会从缓存中读取而不是从存储系统中读取）。

在后面的章节中，我们将更详细地解释我们计划如何记录API模式，但首先让我们快速看看为什么我们应该关心API设计模式。

## 2.2 为什么API设计模式很重要

API设计模式之所以有用，类似于在建造小屋时使用设计图，是因为它们充当我们可以在项目中使用的预先设计的基本模块。然而，我们并没有深入探讨为什么我们需要这些预先设计的图纸。难道我们不足够聪明，可以构建出良好的API吗？难道我们不是最了解我们的业务和技术问题吗？虽然这通常是正确的，但事实是，当设计API时，我们用来构建非常精心设计的软件的一些技术在很大程度上无法奏效。特别是，敏捷开发过程特别推崇的迭代方法在设计API时很难应用。为了理解原因，我们必须探讨软件系统的两个方面。首先，我们必须研究各种接口的灵活性（或刚性），然后必须了解接口的受众对我们的变更和整体设计迭代产生的影响。让我们从灵活性（flexibility）开始。

正如我们在第1章中所看到的，API是一种特殊的接口，主要用于计算系统相互交互。尽管以编程方式访问系统非常有价值，但它也更加脆弱，因为接口的变更很容易导致使用接口的人发生故障。例如，在API中更改字段的名称将导致用户使用旧名称编写的代码发生故障。从API服务器的角度来看，旧代码正在使用一个不再存在的名称请求某个内容。这与其他类型的接口（例如图形用户界面（GUI））非常不同，后者主要由人类而不是计算机使用，因此更能够抵御变化。这意味着尽管变更可能令人不悦，但通常不会导致灾难性故障，使我们完全无法使用接口。例如，更改网页上按钮的颜色或位置可能会很丑陋和不方便，但我们仍然可以弄清楚如何使用接口来完成我们需要做的事情。

通常，我们将接口的这个方面称为其灵活性，即用户可以轻松适应变化的接口是灵活的，而即使是小的变更（例如重命名字段）也会导致完全失败的接口是刚性（rigid）的。这个区别很重要，因为接口是否能够进行大量变化在很大程度上取决于接口的灵活性。最重要的是，我们可以看到刚性接口使我们难以像在其他软件项目中一样向完美的设计不断迭代。这意味着我们通常会被困在设计决策中，无论是好的还是坏的。这可能让你认为API的刚性意味着我们永远无法使用迭代式开发流程。但实际上情况并不总是这样，这要归功于接口的另一个重要方面：可见性（visibility）。

通常，我们可以将大多数接口分为两种不同的类别：用户可以看到和互动的接口（在软件中通常称为前端），以及他们无法看到的接口（通常称为后端）。例如，当我们打开浏览器时，可以轻松看到Facebook的图形用户界面；但是，我们无法看到Facebook如何存储我们的社交图和其他数据。为了对这个可见性方面使用更正式的术语，我们可以说前端（所有用户都可以看到和互动的部分）通常被认为是公共的（public），而后端（只对较小的内部人员组可见）被认为是私有的（private）。这个区别很重要，因为它在一定程度上决定了我们对不同种类的接口（特别是刚性的API）进行变更的能力。

如果我们对公共接口进行变更，整个世界都会看到它，并可能会受到它的影响。由于受众如此之大，粗心地进行变更可能会导致用户沮丧或愤怒。尽管这当然适用于刚性接口，比如API，但它同样适用于灵活的接口。例如，在Facebook的早期，大多数主要功能或设计变更都会在几周内引起大学生的愤怒。但是，如果接口不是公共的，对只有某个内部小组的成员可见的后端接口进行变更是否也很重要？在这种情况下，受变更影响的用户数量要小得多，甚至可能仅限于同一个团队或同一办公室的人员，因此似乎我们重新获得了更多自由来进行变更。这是个好消息，因为这意味着我们应该能够快速迭代朝着理想设计前进，同时应用敏捷原则。

那么，为什么API是特殊的呢？事实证明，当我们设计许多API（根据定义是刚性的）并与世界分享时，实际上存在两个方面（刚性和变更困难）的最坏情况。这意味着进行变更要比这两个属性的任何其他组合更加困难。

<small>表2.2 接口变更的困难度</small>

| 灵活性 | 手中 | 示例接口 | 变更困难度 |
| --- | --- | --- | --- |
| 购买预制的小屋 | 简单 | 无 | 直接使用现成的软件包 |
| 购买套件组装 | 比较简单 | 很小 | 自定义现成的软件包 |
| 按照现成设计图建造 | 一般 | 一般 | 从设计文档开始构建 |
| 从头设计并建造 | 困难 | 最大 | 从头设计软件系统并构建 |

简而言之，这种“两者兼具”的情况（既刚性又难以变更）使得可重复使用且经得起考验的设计模式对于构建API比其他类型的软件更为重要。在大多数软件项目中，代码通常是私有的，但API中的设计决策则是明显可见的，展示给服务的所有用户。由于这严重限制了我们对设计进行渐进性改进的能力，而依赖已经经受时间考验的现有模式会非常有价值——力争在第一次就做对事情而不是像在大多数软件中最终做对事情。

既然我们已经探讨了这些设计模式之所以重要的原因，让我们通过解构并探索它的各个组成部分来深入了解API设计模式。

## 2.3 解构API设计模式

像软件设计中的其他部分一样，API设计模式由几个不同的组件组成，每个组件负责处理模式的不同方面。显然，主要组件关注模式本身的工作原理，但还有其他一些组件针对设计模式的非技术性方面。这些组件包括如何确定某类问题存在某种与之对应的模式、了解模式是否适合你所处理的问题以及了解为什么模式采用的是某种方式而不是其他（可能更简单的）替代方法等等。

由于这个解构过程可能会变得有点复杂，让我们假设我们正在构建一个存储数据的服务，而该服务的客户希望拥有一个API，他们可以从服务中提取数据。我们将依赖这个示例场景来引导接下来要探讨的每个模式组件。首先我们从名称开始说起。

> 译者注：
> 此处提及的设计模式“组件”主要指的是本书在介绍每一种设计模式时遵循的固定流程，即按照“名字和简介，动机，概述接口实现，权衡“的顺序深入探讨每个模式。

### 2.3.1 名称和简介

目录中的每个设计模式都有一个名称，用于在目录中唯一标识模式。名称应足够描述模式的功能，但不要冗长到拗口。例如，当描述解决我们的示例场景——数据导出的模式时，我们可以将其称为“导入、导出、备份、恢复、快照和回滚模式”，但更好的名称可能是“输入/输出模式”或简称为“IO模式”。

虽然名称本身通常足以理解和识别模式，但有时它可能不够详细，无法充分解释模式所解决的问题。为确保对模式本身有一个简短而简单的介绍，名称后面还会有一个模式的简要摘要，其中会简要描述它旨在解决的问题。例如，我们可以说输入/输出模式“提供了一种有序的方式，将数据从各种不同的存储源和目的地移动。” 简而言之，本节的总体目标是使快速识别某个特定模式是否值得进一步研究，以确定是否适合解决特定问题。

### 2.3.2 动机

由于API设计模式的目标是为一类问题提供解决方案，因此最好在开头定义好模式旨在涵盖的问题领域。本节旨在解释基本问题，以便易于理解为什么我们需要这个模式。这意味着我们首先需要一个详细的问题陈述——通常以用户导向进行描述。在数据导出示例中，我们可能有一个场景，其中用户“想要将一些数据从服务中导出到另一个外部存储系统。”

之后，我们必须深入了解用户希望实现的目标细节。例如，我们可能会发现用户需要将其数据导出到各种存储系统，而不仅仅是Amazon的S3。他们还可能需要在传输之前对数据进行进一步约束，例如是否压缩或加密。这些要求将直接影响设计模式本身，因此重要的是我们要详细说明我们使用这个特定模式解决的问题细节。

接下来，一旦我们更全面地了解了用户目标，我们需要探索在实际实现的正常过程中可能出现的特殊情况。例如，我们应该了解当数据太大时系统应该如何反应（以及多大才算太大，因为这些词通常对不同的人有不同的含义）。我们还必须探讨系统遇到异常时应如何反应。例如，当导出作业失败时，我们应该描述是否应重试。这些不寻常的场景可能比我们通常期望的要常见得多，即使我们可能不必立即决定如何解决每个场景，但模式必须照顾到这些真空地带，以便最终可以由具体接口实现进行填补。

### 2.3.3 概述

现在我们越来越接近有趣的部分：解释设计模式建议的解决方案。在这一点上，我们不再专注于定义问题，而是提供解决方案的上层描述。这意味着我们可以开始探讨解决问题所需的策略和方法。例如，在我们的数据导出场景中，这一部分将概述各种组件及其职责，例如一个组件用于描述要导出的数据的详细信息，另一个组件用于描述作为导出数据目的地的存储系统，还有一个组件用于描述在将数据发送到目的地之前应用的加密和压缩设置。

在许多情况下，问题的定义和一系列需求将决定解决方案的一般大纲。在这些情况下，概述的目标是明确表述这个大纲，而不是让它从问题描述中被推断出来，无论解决方案多么明显。例如，如果我们正在定义一个用于搜索资源列表的模式，拥有一个查询参数似乎是相当明显的；但是，其他方面（例如该参数的格式或搜索的一致性保证）可能不那么明显，值得进一步讨论。毕竟，即使明显的解决方案也可能有微妙的影响，值得讨论，正如人们常说的，魔鬼通常隐藏在细节中。

另一方面，虽然问题已经定义得很好，但可能没有明显的单一解决方案，而是有多种不同的选项，每种选项都可能具有自己的利弊。例如，在API中建立多对多关系有许多不同的方法，每种方法都有其不同的优点和缺点；但是，重要的是API选择一种选项并一致地应用它。在这种情况下，概述将讨论每种不同的选项以及推荐模式所采用的策略。这一部分可能包含对提到的其他可能选项的优点和缺点的简要讨论，但更多的讨论将留到模式描述的最后的“权衡”部分。

### 2.3.4 接口实现

每个设计模式的最重要部分已经到来：我们如何实现它。此时，我们应该充分了解我们要解决的问题领域，并对上层策略和解决方法有所了解。这一部分最重要的内容将是以代码形式定义的接口，它解释了使用该模式来解决问题的API会是什么样子。API定义将关注资源的结构以及与这些资源进行各种具体交互的方式。这将包括各种内容，如资源或请求中定义的字段，可以进入这些字段的数据格式（例如Base64编码的字符串），以及资源之间的关系（例如层级关系）。

在许多情况下，API接口和字段定义本身可能无法解释API的实际工作原理。换句话说，虽然结构和字段列表可能看起来很清晰，但这些结构的行为和不同字段之间的交互可能复杂得多。在这些情况下，我们需要更详细地讨论这些并非显而易见的方面。例如，在导出数据时，我们可能会指定一种方法，在将数据传输到存储服务时使用字符串字段来指定压缩算法。在这种情况下，该模式可能会讨论该字段的各种可能值（可能使用与Accept-Encoding HTTP头使用的相同格式），当提供无效选项时应该执行什么操作（可能会返回错误），以及当请求留空该字段时的含义（可能会默认为gzip压缩）。

最后，这一部分将包括一个示例API定义，其中包含了注释来解释正确实现此模式的API应该是什么样的。这将以代码形式定义，其依赖于具体问题的示例场景，包含了解释各个字段行为的注释。这一部分几乎肯定会是最长且包含最多细节的部分。

### 2.3.5 权衡

到目前为止，我们了解了设计模式为我们提供了什么，但我们尚未讨论它带走了什么，实际上这也非常重要。坦白地说，如果严格按设计实现设计模式，可能有些事情是不可能的。在这些情况下，了解为了获得的好处而必须做出的牺牲非常重要。在这里可能会有各种可能性，从功能上的限制（例如，直接将数据作为Web浏览器中的下载提供给用户是不可能的）到增加的复杂性（例如，描述将数据发送到哪里需要更多的输入），甚至到更多的技术方面如数据一致性（例如，您可以看到数据可能有点陈旧，但不能确定）。因此这里的讨论可以既包括简单的解释，也包括在依赖特定设计模式时产生的微小缺陷。

此外，尽管某些设计模式通常适用于特定问题，但肯定会有一些情景，它虽然总体上符合要求，但却不完美。在这些情况下，了解依赖于这种设计模式将会产生什么后果非常重要：不是错误的模式，但也不是完美的模式。本节将讨论这种轻微不匹配的后果。

既然我们对API设计模式的结构和解释有了更好的了解，让我们换个角度看看在构建一个被认为是简单的API时，这些设计模式可以带来的差异。

## 2.4 案例研究: Twapi，一个类似Twitter的API

## 本章总结
