# 第五章 数据类型和默认值

> 本章涵盖：
> - 我们对数据类型的理解
> - 空值与不设置任何值之间的区别
> - 对各种基本数据类型和集合数据类型的探讨
> - 如何处理各种数据类型的序列化

在设计任何API时，我们总是要考虑接受、理解和可能存储的数据类型。有时这听起来可能相当简单：一个名为“name”的字段可能只是一串字符。然而，在这个问题中隐藏着复杂的世界。例如，字符串应该如何表示为字节（事实上有很多选项）？如果在API调用中省略了名称会发生什么？这是否与提供一个空的名称有所不同（例如，`{ "name": "" }`）？在本章中，我们将探讨在设计或使用API时几乎肯定会遇到的各种数据类型，以及如何最好地理解它们的基础数据表示方式，以及如何以明智且直观的方式处理各种类型的默认值。

## 5.1 数据类型介绍

数据类型是几乎每种编程语言中的重要方面，它告诉程序如何处理一块数据以及它应该如何与语言或类型本身提供的各种运算符进行交互。即使在具有动态类型的语言中（其中单个变量可以充当许多不同的数据类型，而不仅仅是限制为一个类型），在单个时间点的类型信息仍然非常重要，它指导编程语言应该如何处理变量。

然而，在设计API时，我们必须摆脱仅考虑单一编程语言的思维模式，因为我们API的主要目标之一是让使用任何编程语言的人与服务进行交互。我们通常通过依赖某种序列化协议来实现这一点，该协议将我们选择的编程语言中的数据的结构化表示转换为一种与语言无关的序列化字节表示，然后将其发送到请求它的客户端。在另一端，客户端反序列化这些字节并将它们转换回内存表示，以便他们可以用他们使用的语言进行交互（这可能与我们使用的语言相同，也可能不同）。请参见图5.1了解此过程。

<small>图5.1 数据从API服务端转移至客户端</small>
![](https://raw.githubusercontent.com/evan-ysj/APIDesignPatternsChinese/main/public/images/5.1.png)

虽然这个序列化过程提供了巨大的好处（基本上允许API被任何编程语言使用），但它并非没有缺点。最大的缺点之一是由于每种语言的行为略有不同，因此在翻译过程中会有一些信息丢失。换句话说，由于不同编程语言的功能差异，所有序列化协议在某种程度上都会有“损失”。

这将我们带回到数据类型的重要性以及如何在API中使用它们。简而言之，仅依赖于我们选择的编程语言提供的数据类型是不够的，尤其是当考虑到使用Web API的人时。相反，我们必须考虑我们选择的序列化格式（最常见的是JSON）提供的数据类型，以及在它不能满足我们需求的情况下如何扩展该格式。这意味着我们需要决定要发送到客户端和从客户端接收的数据类型，并确保对它们进行足够详细的文档化，以便客户端永远不会对它们的行为感到惊讶。

这并不是说Web API必须像关系数据库系统那样具有严格的模式；毕竟，现代开发工具中最强大的功能之一就是动态无模式结构和数据存储提供的灵活性。然而，重要的是要考虑我们正在交互的数据类型，并在必要时用额外的注释来澄清。没有这些有关数据的额外上下文，我们可能会陷入猜测客户端实际意图的困境。例如，对于数字值，a + b可能会以一种方式工作（例如，2 + 4可能会得到6），但对于文本值，它可能会完全不同（例如，“2” + “4”可能会得到“24”）。如果没有这种类型上下文，当客户端使用+运算符时，我们将被迫猜测它的意图：是加法还是连接？而且如果一个值是数字而另一个值是字符串呢？这可能导致更多的猜测。那么，如果一个值完全被省略呢？

### 5.1.1 省略 vs NULL

令人惊讶的是，最令人困惑的一个方面是数据缺失而不是存在的情况。首先，在许多序列化格式中，存在一个`null`值，它是一个表示非值的标志（例如，字符串可以是值，也可以是文字`null`）。那么，例如，API在尝试添加`null`和`2`时应该如何行为？任何使用支持此类`null`值的序列化格式的API都需要决定如何最好地处理其API的此类输入。它应该假装`null`在数学上等同于`0`吗？试图添加`null`和"value"呢？在这种情况下，`null`是否应该被解释为空字符串("")并尝试连接它呢？

更糟糕的是，动态数据结构（例如JSON对象）有一个新问题：如果值根本不存在怎么办？换句话说，与显式设置为null的值相比，如果存储该值的键完全缺失了呢？这是否被视为与明确的null值相同？为了了解这意味着什么，想象一下你有一个期望包含名称和颜色的`Fruit`资源，两者都是字符串数据类型。考虑以下示例JSON对象以及API可能为资源的颜色值辨别出的值：

```
fruit1 = { name: "Apple", color: "red" };
fruit2 = { name: "Apple", color: "" };
fruit3 = { name: "Apple", color: null };
fruit4 = { name: "Apple" };
```

如您所见，第一个颜色值是明显的（`fruit1.color == "red"`）。然而，对于其他情况应该怎么办呢？空颜色（""）是否与显式null颜色相同（`fruit2.color`是否与`fruit3.color`有所不同）？那么缺少颜色值的水果呢？`fruit3.color`是否与`fruit4.color`有所不同？这些可能只是JSON的缺陷，然而，它们确实存在于许多其他序列化格式中（例如，Google的Protocol Buffers [https://opensource.google/projects/protobuf] 在这个领域有一些令人困惑的行为），它们提供了每个API都必须解决的场景，否则可能会对使用API的人产生极大的不一致和混乱。换句话说，您不能简单地假设序列化库会做正确的事情，因为几乎可以肯定每个人都会使用不同的序列化库！

在本章中，我们将遍历所有常见的数据类型，从简单的（有时称为基本数据类型）开始，逐渐过渡到更复杂的类型（如映射和集合）。您应该已经对这些概念大致熟悉，因此重点将不再是每种数据类型的基础知识，而更多地关注在Web API中使用它们时需要考虑的问题。我们将深入研究每种数据类型的不同“陷阱”，以及如何最好地为任何API解决这些问题。我们还将坚持使用JSON作为首选的序列化格式，但大多数建议都适用于支持动态数据结构的任何格式，包括隐式和显式类型定义。让我们从最简单的开始：`true` 和 `false` 值。

## 5.2 布尔类型

在大多数编程语言中，布尔值是最简单的数据类型，表示两个值中的一个：`true` 或 `false`。由于这个有限的值集，我们倾向于依赖布尔值来存储标志（flag）或简单的是或否问题。例如，我们可能会在聊天室上存储一个标志，用于指示房间是否已存档或是否允许在房间中使用聊天机器人。

<small>代码5.1 带有布尔标志的聊天室</small>
```typescript
interface ChatRoom {
    id: string;
    // ...
    archived: boolean;
    allowChatbots: boolean;
}
```

然而，布尔标志在将来的情况下可能会受到限制，其中是或否的问题可能会变成一个更一般的问题，这就需要其他方式能够比布尔字段提供更细致的答案。例如，可能会出现这样的情况，聊天室允许各种不同类型的参与者，而不仅仅是普通用户和聊天机器人。在这种情况下，我们目前的设计将导致一个包含每种允许（或不允许）的类型的长列表，例如 `allowChatbots`、`allowModerators`、`allowChildren`、`allowAnonymousUsers` 等等。如果这是一种可能性，实际上可能更明智的做法是避免使用一组布尔标志，而是依赖于不同的数据类型或结构来定义哪些参与者被允许或不允许进入特定的聊天室。

假设布尔字段是变量的正确选择，还有一些其他有趣的方面需要考虑。在布尔字段的名称中隐藏着字段是正面还是负面的陈述。在 `allowChatbots` 的例子中，字段的 `true` 值表示允许聊天机器人进入聊天室。但它同样可以是 `disallowChatbots`，其中 `true` 值将禁止聊天机器人进入聊天室。为什么要选择其中之一呢？

对于大多数人来说，正面的布尔字段最容易理解，原因很简单：人们在处理双重否定时需要花费更多思考。而对于否定字段的 `false` 值也是如此。例如，想象一下字段是 `disallowChatbots`。您如何检查在给定的聊天室中是否允许聊天机器人呢？

<small>代码5.2 添加机器人到聊天室</small>
```typescript
function addChatbotToRoom(chatbot: Chatbot,
    roomId: number): void {
    let room = getChatRoomById(roomId);
    if (room.disallowChatbots === false) {
        chatbot.join(room.id);
    }
}
```

这是不是难以理解？可能不是。是否比简单版本（`if (room.allowChatbots) { ... }`）增加了一些认知负担？对于大多数人来说，可能是的。仅仅基于这一点，选择使用正面的布尔标志总是更明智的。但在考虑字段的默认或未设置值时，也存在一些场景可能更适合依赖负面标志。

例如，在某些语言或序列化格式中（例如，直到最近，Google 的 Protocol Buffers v3），许多基础类型，如布尔字段，只能具有零值，而不能是 `null` 或缺失值。正如您可能猜到的，对于布尔值，零值几乎总是等于 `false`。这意味着当我们考虑在创建聊天室时的 `allowChatbots` 字段的值时，如果没有进一步的干预，聊天室不允许聊天机器人（`defaultChatRoom.allowChatbots == false`）。但我们无法区分用户是否说：“我没有设置这个值，请按照你认为最好的方式处理”（即 `null` 或缺失值）和“我不想允许聊天机器人”（即明确的 `false` 值）。在这两种情况下值都只是 `false`。我们该怎么办呢？

虽然有很多解决这个问题的方法，但一种常见的选择是依赖布尔字段名称的正面或负面特性，以确定“正确”的默认值。换句话说，我们可以选择为布尔字段命名，使得零值提供我们想要的默认值。例如，如果我们希望默认允许匿名用户，我们可以决定将字段命名为 `disallowAnonymousUsers`，以便零值（`false`）会导致我们想要的默认值（允许匿名用户）。不幸的是，这种选择将默认值锁定在字段的名称中，这会限制未来的灵活性（即您无法在以后更改默认值），但正如人们所说，非常情况用非常手段。

## 5.3 数值类型

### 5.3.1 界限

### 5.3.2 默认值

### 5.3.3 序列化

## 5.4 字符串

### 5.4.1 界限

### 5.4.2 默认值

### 5.4.3 序列化

## 5.5 枚举类型

## 5.6 列表

### 5.6.1 原子性

### 5.6.2 界限

### 5.6.3 默认值

## 5.7 映射

### 5.7.1 界限

### 5.7.2 默认值

## 5.8 练习

## 本章总结