# 第五章 数据类型和默认值

> 本章涵盖：
> - 我们对数据类型的理解
> - 空值与不设置任何值之间的区别
> - 对各种基本数据类型和集合数据类型的探讨
> - 如何处理各种数据类型的序列化

在设计任何API时，我们总是要考虑接受、理解和可能存储的数据类型。有时这听起来可能相当简单：一个名为“name”的字段可能只是一串字符。然而，在这个问题中隐藏着复杂的世界。例如，字符串应该如何表示为字节（事实上有很多选项）？如果在API调用中省略了名称会发生什么？这是否与提供一个空的名称有所不同（例如，`{ "name": "" }`）？在本章中，我们将探讨在设计或使用API时几乎肯定会遇到的各种数据类型，以及如何最好地理解它们的基础数据表示方式，以及如何以明智且直观的方式处理各种类型的默认值。

## 5.1 数据类型介绍

数据类型是几乎每种编程语言中的重要方面，它告诉程序如何处理一块数据以及它应该如何与语言或类型本身提供的各种运算符进行交互。即使在具有动态类型的语言中（其中单个变量可以充当许多不同的数据类型，而不仅仅是限制为一个类型），在单个时间点的类型信息仍然非常重要，它指导编程语言应该如何处理变量。

然而，在设计API时，我们必须摆脱仅考虑单一编程语言的思维模式，因为我们API的主要目标之一是让使用任何编程语言的人与服务进行交互。我们通常通过依赖某种序列化协议来实现这一点，该协议将我们选择的编程语言中的数据的结构化表示转换为一种与语言无关的序列化字节表示，然后将其发送到请求它的客户端。在另一端，客户端反序列化这些字节并将它们转换回内存表示，以便他们可以用他们使用的语言进行交互（这可能与我们使用的语言相同，也可能不同）。请参见图5.1了解此过程。

<small>图5.1 数据从API服务端转移至客户端</small>
![](https://raw.githubusercontent.com/evan-ysj/APIDesignPatternsChinese/main/public/images/5.1.png)

虽然这个序列化过程提供了巨大的好处（基本上允许API被任何编程语言使用），但它并非没有缺点。最大的缺点之一是由于每种语言的行为略有不同，因此在翻译过程中会有一些信息丢失。换句话说，由于不同编程语言的功能差异，所有序列化协议在某种程度上都会有“损失”。

这将我们带回到数据类型的重要性以及如何在API中使用它们。简而言之，仅依赖于我们选择的编程语言提供的数据类型是不够的，尤其是当考虑到使用Web API的人时。相反，我们必须考虑我们选择的序列化格式（最常见的是JSON）提供的数据类型，以及在它不能满足我们需求的情况下如何扩展该格式。这意味着我们需要决定要发送到客户端和从客户端接收的数据类型，并确保对它们进行足够详细的文档化，以便客户端永远不会对它们的行为感到惊讶。

这并不是说Web API必须像关系数据库系统那样具有严格的模式；毕竟，现代开发工具中最强大的功能之一就是动态无模式结构和数据存储提供的灵活性。然而，重要的是要考虑我们正在交互的数据类型，并在必要时用额外的注释来澄清。没有这些有关数据的额外上下文，我们可能会陷入猜测客户端实际意图的困境。例如，对于数字值，a + b可能会以一种方式工作（例如，2 + 4可能会得到6），但对于文本值，它可能会完全不同（例如，“2” + “4”可能会得到“24”）。如果没有这种类型上下文，当客户端使用+运算符时，我们将被迫猜测它的意图：是加法还是连接？而且如果一个值是数字而另一个值是字符串呢？这可能导致更多的猜测。那么，如果一个值完全被省略呢？

### 5.1.1 省略 vs NULL

令人惊讶的是，最令人困惑的一个方面是数据缺失而不是存在的情况。首先，在许多序列化格式中，存在一个`null`值，它是一个表示非值的标志（例如，字符串可以是值，也可以是文字`null`）。那么，例如，API在尝试添加`null`和`2`时应该如何行为？任何使用支持此类`null`值的序列化格式的API都需要决定如何最好地处理其API的此类输入。它应该假装`null`在数学上等同于`0`吗？试图添加`null`和"value"呢？在这种情况下，`null`是否应该被解释为空字符串("")并尝试连接它呢？

更糟糕的是，动态数据结构（例如JSON对象）有一个新问题：如果值根本不存在怎么办？换句话说，与显式设置为null的值相比，如果存储该值的键完全缺失了呢？这是否被视为与明确的null值相同？为了了解这意味着什么，想象一下你有一个期望包含名称和颜色的`Fruit`资源，两者都是字符串数据类型。考虑以下示例JSON对象以及API可能为资源的颜色值辨别出的值：

```
fruit1 = { name: "Apple", color: "red" };
fruit2 = { name: "Apple", color: "" };
fruit3 = { name: "Apple", color: null };
fruit4 = { name: "Apple" };
```

如您所见，第一个颜色值是明显的（`fruit1.color == "red"`）。然而，对于其他情况应该怎么办呢？空颜色（""）是否与显式null颜色相同（`fruit2.color`是否与`fruit3.color`有所不同）？那么缺少颜色值的水果呢？`fruit3.color`是否与`fruit4.color`有所不同？这些可能只是JSON的缺陷，然而，它们确实存在于许多其他序列化格式中（例如，Google的Protocol Buffers [https://opensource.google/projects/protobuf] 在这个领域有一些令人困惑的行为），它们提供了每个API都必须解决的场景，否则可能会对使用API的人产生极大的不一致和混乱。换句话说，您不能简单地假设序列化库会做正确的事情，因为几乎可以肯定每个人都会使用不同的序列化库！

在本章中，我们将遍历所有常见的数据类型，从简单的（有时称为基本数据类型）开始，逐渐过渡到更复杂的类型（如映射和集合）。您应该已经对这些概念大致熟悉，因此重点将不再是每种数据类型的基础知识，而更多地关注在Web API中使用它们时需要考虑的问题。我们将深入研究每种数据类型的不同“陷阱”，以及如何最好地为任何API解决这些问题。我们还将坚持使用JSON作为首选的序列化格式，但大多数建议都适用于支持动态数据结构的任何格式，包括隐式和显式类型定义。让我们从最简单的开始：`true` 和 `false` 值。

## 5.2 布尔类型

在大多数编程语言中，布尔值是最简单的数据类型，表示两个值中的一个：`true` 或 `false`。由于这个有限的值集，我们倾向于依赖布尔值来存储标志（flag）或简单的是或否问题。例如，我们可能会在聊天室上存储一个标志，用于指示房间是否已存档或是否允许在房间中使用聊天机器人。

<small>代码5.1 带有布尔标志的聊天室</small>
```typescript
interface ChatRoom {
    id: string;
    // ...
    archived: boolean;
    allowChatbots: boolean;
}
```

然而，布尔标志在将来的情况下可能会受到限制，其中是或否的问题可能会变成一个更一般的问题，这就需要其他方式能够比布尔字段提供更细致的答案。例如，可能会出现这样的情况，聊天室允许各种不同类型的参与者，而不仅仅是普通用户和聊天机器人。在这种情况下，我们目前的设计将导致一个包含每种允许（或不允许）的类型的长列表，例如 `allowChatbots`、`allowModerators`、`allowChildren`、`allowAnonymousUsers` 等等。如果这是一种可能性，实际上可能更明智的做法是避免使用一组布尔标志，而是依赖于不同的数据类型或结构来定义哪些参与者被允许或不允许进入特定的聊天室。

假设布尔字段是变量的正确选择，还有一些其他有趣的方面需要考虑。在布尔字段的名称中隐藏着字段是正面还是负面的陈述。在 `allowChatbots` 的例子中，字段的 `true` 值表示允许聊天机器人进入聊天室。但它同样可以是 `disallowChatbots`，其中 `true` 值将禁止聊天机器人进入聊天室。为什么要选择其中之一呢？

对于大多数人来说，正面的布尔字段最容易理解，原因很简单：人们在处理双重否定时需要花费更多思考。而对于否定字段的 `false` 值也是如此。例如，想象一下字段是 `disallowChatbots`。您如何检查在给定的聊天室中是否允许聊天机器人呢？

<small>代码5.2 添加机器人到聊天室</small>
```typescript
function addChatbotToRoom(chatbot: Chatbot,
    roomId: number): void {
    let room = getChatRoomById(roomId);
    if (room.disallowChatbots === false) {
        chatbot.join(room.id);
    }
}
```

这是不是难以理解？可能不是。是否比简单版本（`if (room.allowChatbots) { ... }`）增加了一些认知负担？对于大多数人来说，可能是的。仅仅基于这一点，选择使用正面的布尔标志总是更明智的。但在考虑字段的默认或未设置值时，也存在一些场景可能更适合依赖负面标志。

例如，在某些语言或序列化格式中（例如，直到最近，Google 的 Protocol Buffers v3），许多基础类型，如布尔字段，只能具有零值，而不能是 `null` 或缺失值。正如您可能猜到的，对于布尔值，零值几乎总是等于 `false`。这意味着当我们考虑在创建聊天室时的 `allowChatbots` 字段的值时，如果没有进一步的干预，聊天室不允许聊天机器人（`defaultChatRoom.allowChatbots == false`）。但我们无法区分用户是否说：“我没有设置这个值，请按照你认为最好的方式处理”（即 `null` 或缺失值）和“我不想允许聊天机器人”（即明确的 `false` 值）。在这两种情况下值都只是 `false`。我们该怎么办呢？

虽然有很多解决这个问题的方法，但一种常见的选择是依赖布尔字段名称的正面或负面特性，以确定“正确”的默认值。换句话说，我们可以选择为布尔字段命名，使得零值提供我们想要的默认值。例如，如果我们希望默认允许匿名用户，我们可以决定将字段命名为 `disallowAnonymousUsers`，以便零值（`false`）会导致我们想要的默认值（允许匿名用户）。不幸的是，这种选择将默认值锁定在字段的名称中，这会限制未来的灵活性（即您无法在以后更改默认值），但正如人们所说，非常情况用非常手段。

## 5.3 数值类型

比起简单的是或否问题，数值字段稍微复杂一些，它们允许我们存储各种有价值的信息，如计数（例如 `viewCount`）、尺寸和距离（例如 `itemWeight`）或货币值（例如 `priceUsd`）。总体而言，任何我们可能想要进行算术计算的内容（即使这些计算只是在逻辑上有意义），数值字段都是理想的数据类型选择。

有一个显著的例外实际上并不适合这种数据类型：数值标识符（ID）。这可能让人感到惊讶，因为许多数据库系统（几乎所有关系数据库系统）使用自动增加的整数值作为行的主键标识符。那么为什么我们在API中不这样做呢？

虽然我们可能出于各种原因（例如性能或空间限制）在底层仍然使用数值字段，但在API界面上，数值类型最适合于可以提供算数方面便利的情景。换句话说，如果API公开的物品具有以克为单位的重量值，我们可以想象将所有这些值相加，以确定这些物品的组合重量。而另一方面，一组数值标识符的相加并不会产生什么意义。因此，重要的是要依赖数值数据类型的数值或算术好处，而不是它们碰巧只用数字字符编写（这里或那里可能有小数点）。通常，那些只看起来像数字但更像令牌或符号的值可能应该是字符串值而不是数值（参见第5.4节）。

话虽如此，在API中使用数值值时，有一些事项需要考虑。让我们首先看看如何定义这些数值字段的可接受值的范围或界限。

### 5.3.1 界限

在定义数值字段的边界时，无论是整数还是小数（或其他数学表示，如分数、虚数等），都需要考虑上限或最大值、下限或最小值以及零值。由于它们彼此之间存在影响，让我们考虑绝对值边界，然后决定是否利用该范围的负面和正面。

在边界方面，我们主要关注它们的大小。换句话说，所有数字最终都需要存储在某个地方，这意味着我们需要知道为这些值分配多少位的空间。对于小整数，可能8位足够了，有256个可能的值（从-127到127）。对于大多数常见的数字值，32位通常是可接受的大小，有大约40亿个可能的值（从负20亿到正20亿）。对于我们可能关心的大多数情况，64位是一个安全的大小，有大约18万亿个可能的值（从负9万亿到正9万亿）。当我们引入浮点数时，这个范围变得有些混乱，因为有很多不同的表示，存储这些值的位数多达256位，但关键是通常有一种表示方式适用于您在API中考虑的范围。

虽然这些都是可以接受的选择，您可能会想知道为什么我们要关注存储在某个数据库中的数字的大小。毕竟，API的目的不就是要抽象掉所有这些吗？这是正确的；但是，这很重要，因为不同的计算机和不同的编程语言处理数字的方式并不一致。例如，JavaScript甚至没有一个合适的整数值，而是只有一个处理语言所有数值的数字类型。此外，许多语言以非常不同的方式处理非常大的数字。例如，在Python 2中，int类型可以存储32位整数，而long类型可以处理任意大的数字，最少存储36位。简而言之，这意味着如果API响应向消费者发送一个非常大的数字，接收端的语言可能无法正确解析和理解它。此外，那些可能收到这些巨大数字的人需要知道为存储它们分配多少空间。简而言之，边界将非常重要。

因此，通常的做法是在内部使用64位整数类型来处理整数，除非有很好的理由不这样做。一般来说，即使当前可能根本不需要接近64位范围，但在软件中绝对的确定性是罕见的，因此更安全的做法是设置合理上下限，使其具有一定的增长空间。

### 5.3.2 默认值

如我们在5.1.1节中学到的那样，对于大多数数据类型，我们还有其他情景需要考虑，特别是空值和缺失值。其中字段被简单省略，就像布尔值（5.2节）一样，但在不提供空值的序列化格式中，我们将无法区分0（或0.0）的真值和用户表示“我在这里没有意见，所以你可以为我选择最好的”默认值。

虽然有可能依赖零值作为默认值的标志，但这有一些问题。首先，零值作为API的一部分实际上可能是有意义且是必要的；然而，如果我们将其用作默认值的指示器，我们将无法指定零的实际值。换句话说，如果我们使用0来表示“做最好的选择”（在这种情况下可能是57），我们无法刻意指定零值（因为0用来代表了一种默认情况并映射到其他值）。其次，在零值可能具有逻辑意义的情况下，将此值用作标志可能令人困惑，并导致意外后果，违反了一些良好API的关键原则（在这种情况下是可预测性）。为了回答处理数值的默认值的问题，我们实际上需要转换思路，并更详细地讨论这些值应该如何序列化。

### 5.3.3 序列化

正如我们在5.3.1节中学到的，一些编程语言对待数值与其他语言不同。这在我们有非常大的数字时特别明显，至少在32位数字以上，但在超过64位限制的数字中更为明显。在处理小数时，由于浮点精度的问题，这也经常出现，这是这种格式设计的众所周知的缺点。

不过，最终我们需要将数值发送给API用户（并从这些用户那里接收传入的数值）。如果我们打算依赖于序列化库而不深入挖掘任何更深层次的东西，那么我们可能会感到非常失望。

<small>代码5.3 两个不同的大数被视为相等</small>
```typescript
const compareJsonNumbers(): boolean {
    // 这两个数字相差1。但是如果我们使用JSON解析后再比较，
    // Node.JS会显示他们相等。
    const a = JSON.parse('{"value": 9999999999999999999999999}');
    const b = JSON.parse('{"value": 9999999999999999999999998}');
    return a['value'] == b['value'];
}
```

这个问题不仅仅局限于大整数。在处理小数时，浮点数算术也存在问题。

<small>代码5.4 两个浮点数相加时的问题</small>
```typescript
const jsonAddition(): number {
    const a = JSON.parse('{"value": 0.1}');
    const b = JSON.parse('{"value": 0.2}');
    // 很遗憾，这里会返回0.30000000000000004而非0.3
    return a['value'] + b['value'];
}
```

那么我们该怎么办呢？代码5.4中的情况足以表明，使用数值并假设它们在各种语言中都相同可能会让人感到非常担忧。答案可能会让一些纯粹主义者感到沮丧，但它确实效果很好：使用字符串。

这种简单的策略，在序列化时将数值表示为字符串值，只是一种避免这些基本数值被解释为实际数值的机制。相反，这些值本身可以由一个库来解释，该库可能更擅长处理这些类型的情况。换句话说，与其让一个JSON库将0.2解析为JavaScript的Number类型，我们可以使用Decimal.js等库将值解析为任意精度的十进制类型。

<small>代码5.5 避免两个浮点数相加的问题</small>
```typescript
const Decimal = require('decimal.js');
const jsonDecimalAddition(): number {
    // 注意这里的数值是字符串类型
    const a = JSON.parse('{"value": "0.1"}');
    const b = JSON.parse('{"value": "0.2"}');
    // 当我们使用一个类似Decimal.js这样的任意精度函数库，
    // 我们可以得到正确的值0.3。
    return Decimal(a['value']).add(Decimal(b['value']);
}
```

由于这种策略的基础依赖于字符串，让我们花一些时间来探讨字符串字段。

## 5.4 字符串

在几乎所有的编程语言中，我们往往认为字符串是理所当然的东西，而不真正了解它们在底层是如何工作的。即使是那些花时间学习C语言如何处理字符串的人，也倾向于回避字符编码和Unicode的广阔世界。虽然成为Unicode、字符编码或其他与字符串相关的主题的专家并非必须，但在考虑如何在API中处理字符串时，有一些东西是相当重要的。由于API中的大多数字段通常是字符串，这显得尤为重要。

在西方世界，可以相对安全地将字符串视为表示文本内容的单个字符的集合。这是一个相当大的概括，但这不是一本关于Unicode的书籍，因此我们必须概括处理。由于我们想要在API中传达的大部分内容都是文本性质的，字符串可能是所有可用数据类型中最有用的。

在构建API时，字符串也可能是最通用的数据类型。它们可以处理像名称、地址和摘要这样的简单字段；它们可以负责处理长篇文本；在序列化格式不支持通过网络发送原始字节的情况下，它们可以表示编码的二进制数据（例如，Base64编码的字节）。对于存储唯一标识符，字符串也是最合适的选项，即使这些标识符看起来更像是数字而不是文本。在底层可能将它们存储为字节（有关更多信息，请参阅第6章），但在API中的表示几乎肯定最适合使用字符字符串。

在我们开始赞美字符串是世界的救世主之前，让我们花一些时间看看字符串字段的一些潜在陷阱以及我们如何最有效地使用它们，首先是边界条件。

### 5.4.1 界限

正如我们在第5.3.1节中学到的，边界条件很重要，因为最终我们必须考虑分配多少空间来存储数据。就像在数字值中一样，对于字符串值，我们也需要考虑相同的方面。如果您曾经为关系数据库定义模式（schema），并最终得到了`VARCHAR(128)`之类的东西，其中的128是一个完全随意的选择，那么您应该对这种有时令人不悦的必要性很熟悉。

正如我们从数字中学到的那样，这些大小限制很重要，因为接收数据的一方需要知道分配多少空间来存储这些值。就像数字一样，由于在API生命周期的早期低估而导致增加大小是一种相当令人不适和不幸的情况。因此，通常最好在选择字符串字段的最大长度时选择向上取整。

然而，值得解决的下一个问题是如何定义最大长度。事实证明，我们最初将字符串定义为字符的集合仅在一些有限的情况下有效，因为许多编程语言并没有像我们期望的那样密切遵循这个概念。然而，更大的问题是，存储空间（磁盘上的字节）的单位与字符串长度的测量单位（我们称之为字符）之间并没有一对一的关系。我们该怎么办呢？

为了避免写一整章关于 Unicode 的内容，对于这个问题的最简单答案是继续以字符为单位思考（即使这些实际上是 Unicode 代码点），然后假设存储使用最冗长的序列化格式：UTF-32。这意味着当我们存储字符串数据时，我们为每个字符分配4个字节，而不是使用 ASCII 时可能期望的单个字节。

尽管存在存储空间的难题，但对于每个字符串字段，我们还需要考虑另一个方面：处理过多的输入。对于数值，超出范围的数字可以被API安全地拒绝，并附上友好的错误消息：“请在0到10之间选择一个值。”对于字符串值，我们实际上有两种不同的选择。我们可以始终拒绝超出范围的值，就像数字超出范围一样，但根据具体情况和上下文，这可能有点不必要。或者，我们可以选择在超出定义的限制后截断文本。

虽然截断可能看起来是个好主意，但它可能会误导和令人困惑，这两者都不是一个好的API的特征，正如我们在第1章中探讨的那样。这还为API引入了一组新的选择（这个字段应该截断还是拒绝？），这可能会导致更多的不可预测性，因为不同的字段展现出不同的行为。因此，与数字一样，通常最明智的做法是拒绝任何超出字段定义限制的输入。

### 5.4.2 默认值

与数字和布尔字段类似，许多序列化格式并不一定允许存在一个明确的空值（`null`），与零值（""）不同。因此，确定用户是指定字符串为空字符串，还是用户要求API“根据上下文做最好的选择”是很困难的。

幸运的是，有很多选项可供选择。在许多情况下，空字符串根本不是字段的有效值。因此，空字符串确实可以用作指示默认值的标志。在其他情况下，字符串值可能具有一组特定的适当值，空字符串是其中的一种选择。在这种情况下，允许选择 "default" 作为一个标志指示默认值是完全合理的。

### 5.4.3 序列化

由于 Unicode 标准的普及，几乎所有的序列化框架和编程语言都以基本相同的方式处理字符串。这意味着，与我们在第 5.3 节中探讨的数值值不同，我们的重点不再是精度或微妙的溢出错误，而更多地是安全地处理字符串，这些字符串可能跨越整个人类语言谱系，而不仅仅是西方世界所使用的字符。

在底层，字符串实际上只是一组字节。然而，我们如何解释这些字节（编码）告诉我们如何将它们转换为看起来像实际文本的东西 - 无论我们正在使用的语言是什么。简而言之，这意味着当我们准备在 API 服务器上序列化字符串时，我们不能只是以我们当前使用的任何编码将其发送回去。相反，我们应该在所有请求和响应中始终一致地使用单一的编码格式。

虽然有很多编码格式（例如 ASCII、UTF-8 [https://tools.ietf.org/html/rfc3629]、UTF-16 [https://tools.ietf.org/html/rfc2781] 等），但世界已经趋向于使用 UTF-8，因为它对于大多数常见字符来说相当紧凑，同时仍然灵活到足以编码所有可能的 Unicode 代码点。大多数面向字符串的序列化格式（例如 JSON 和 XML；https://www.w3.org/TR/xml/）已经确定使用 UTF-8，而其他格式（例如 YAML）则没有明确注明必须使用哪种编码。简而言之，除非有很好的理由不这样做，API 应该使用 UTF-8 编码所有的字符串内容。

如果你认为这是一个我们可以让库来处理的地方，你几乎是对的，但还不太对。事实证明，即使在我们指定了一个编码之后，由于 Unicode 的规范化形式 (https://unicode.org/reports/tr15/#Norm_Forms)，仍然有多种方法来表示相同的字符串内容。可以将其视为表示数字 4 的各种方式：4、1+3、2+2、2*2、8/2 等。在 UTF-8 编码的字符串中，可以使用相同的二进制表示方式。例如，字符 “è” 可以表示为单个特殊字符 (“è” 或 0x00e9)，也可以表示为基本字符 (“e” 或 0x0065) 与重音字符 (“`” 或 0x0301) 的组合。这两种表示在视觉和语义上是相同的，但它们在磁盘上的字节表示不同，因此对于进行精确匹配的计算机来说，它们是完全不同的值。

为了解决这个问题，Unicode (http://www.unicode.org/versions/Unicode13.0.0/) 支持不同的规范化形式，并且一些序列化格式（例如 XML）标准化了特定的形式（在 XML 的情况下，规范化形式 C），以避免混合和匹配这些在语义上相同的文本表示。尽管这对于表示 API 资源描述的字符串可能没有那么重要，但当字符串表示标识符时，这变得非常重要。如果标识符具有不同的字节表示，那么可能相同的语义标识符实际上指的是不同的资源。因此，API 最好拒绝不使用规范化形式 C 进行 UTF-8 编码的字符串，而对于表示资源标识符的字符串来说，这是绝对必要的。有关标识符及其格式的更多信息，请参阅第 6 章。

## 5.5 枚举类型

## 5.6 列表

### 5.6.1 原子性

### 5.6.2 界限

### 5.6.3 默认值

## 5.7 映射

### 5.7.1 界限

### 5.7.2 默认值

## 5.8 练习

## 本章总结