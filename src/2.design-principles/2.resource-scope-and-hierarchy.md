# 第四章 资源规模和层级

> 本章涵盖：
> - 什么是资源布局
> - 资源关系的各种类型（引用、多对多等）
> - 实体关系图是如何描述资源布局的
> - 如何选择资源之间的正确关系
> - 需要避免的资源布局反模式

正如我们在第1章中学到的，将我们的注意力从操作转向资源使我们能够通过利用简单的模式更轻松、更快速地熟悉API。例如，REST提供了一组标准动词，我们可以将其应用于许多资源，这意味着对于我们了解的每个资源，我们还可以掌握对该资源执行的五种不同操作（create、get、list、delete和update）。

尽管这很有价值，但这意味着我们需要更加慎重的定义API资源。选择正确的资源的关键部分是了解它们将来如何相互关联。在本章中，我们将探讨如何布局API中的各种资源、可用的选项以及选择正确的方式将资源彼此关联。此外，我们将讨论在考虑如何布局API中的资源时要避免的一些反模式（anti-patterns）（不应该做的事情）。让我们从具体了解资源布局的含义开始。

## 4.1 什么是资源布局

当我们谈论资源布局时，通常指的是API中资源（或“事物”）的排列方式，定义这些资源的字段，以及这些资源如何通过这些字段相互关联。换句话说，资源布局是特定API设计的实体（资源）关系模型。例如，如果我们要构建一个聊天室的API，资源布局是指我们可能选择创建ChatRoom资源以及与ChatRoom有某种相关的User资源。我们感兴趣的是User和ChatRoom资源之间的关联方式。如果您曾经设计过具有各种表的关系数据库，这应该感觉很熟悉：您设计的数据库模式在本质上与API的表示方式非常相似。

虽然可能会说关系是唯一重要的事情，但实际上情况要复杂一些。虽然关系本身是对最终资源布局唯一有直接影响的因素，但还有许多其他因素间接影响布局。一个明显的例子是资源选择本身：如果我们选择不使用User资源，而是坚持使用按名称列出用户的简单列表（`members: string[]`），那么就没有其他资源可以布局，问题就被完全回避了。

正如名称所示，API的资源布局在视觉上可能最容易理解，即将它看作由线连接在一起的方框。例如，图4.1显示了我们可能如何考虑聊天室示例，其中有许多用户和许多聊天室彼此相互连接。

<small>图4.1 一个有很多成员的聊天室</small>
![](https://raw.githubusercontent.com/evan-ysj/APIDesignPatternsChinese/main/public/images/4.1.png)

如果我们正在构建一个在线购物API（例如，类似于亚马逊），我们可能会存储User资源以及他们的各种地址（用于运送在线购买的物品）和付款方式。此外，付款方式本身可能会引用付款方式的账单地址。这个布局如图4.2所示。

<small>图4.2 用户，付款方式和地址之间有不同的对应关系</small>
![](https://raw.githubusercontent.com/evan-ysj/APIDesignPatternsChinese/main/public/images/4.2.png)

简而言之，要记住资源布局是一个广泛的概念，涵盖了所有我们为API定义的资源。最重要的是这些资源如何相互交互和关联。在下一节中，我们将简要介绍不同类型的关系以及每种类型可能提供的交互（和限制）。

### 4.1.1 资源关系的类型

在考虑资源布局时，我们必须考虑资源关系的多种方式。重要的是要注意，我们将讨论的所有关系都是双向的，这意味着即使关系看起来是单向的（例如，一条消息指向一个用户作为作者），反向关系仍然存在，即使它没有明确定义（例如，一个用户可以是多条不同消息的作者）。让我们直接开始看最常见的关系形式：引用。

**引用关系**

两个资源相互关联的最简单方式是通过简单的引用。这意味着一个资源引用或指向另一个资源。例如，在聊天室API中，我们可能有组成聊天室内容的Message资源。在这种情况下，每条消息显然会由单个用户撰写，并存储在消息的作者字段中。这将导致消息和用户之间存在简单的引用关系：消息有一个指向特定用户的作者字段，如图4.3所示。

<small>图4.3 一个Message资源包含了对其作者（User资源）的引用</small>
![](https://raw.githubusercontent.com/evan-ysj/APIDesignPatternsChinese/main/public/images/4.3.png)

这种引用关系有时被称为外键（foreign key）关系，因为每个Message资源将指向一个确切的User资源作为作者。但正如前面提到的，一个User资源显然可以与许多不同的消息相关联。因此，这也可以被视为一对多关系，其中用户可能写多条消息，但每条消息始终有一个用户作为作者。

**多对多关系**

就像引用关系的一种更复杂的版本，一对多关系代表了每个资源指向另一个资源的多个实例的情况。例如，如果我们有一个用于组群对话的ChatRoom资源，这显然会包含许多个体用户作为成员。但是，每个用户也可以是多个不同聊天室的成员。在这种情况下，ChatRoom资源与用户之间存在一对多关系。ChatRoom指向很多User资源作为房间的成员，并且用户能够指向多个聊天室。

关于这种关系的工作原理的具体机制将在未来进行探讨（我们将在第三部分中看到这些），但这些多对多关系在API中非常常见，并且有几种不同的选项可以表示它们，每种选项都有其自己的优点和缺点。

**自引用关系**

在这一点上，我们可以讨论一种可能听起来奇怪但实际上只是引用的另一个特殊版本：自引用（self-reference）。顾名思义，在这种关系中，一个资源指向与其自身相同类型的另一个资源，因此"self"指的是类型而不是资源本身。实际上，这与普通的引用关系完全相同；但是，由于其典型的可视化表示（其中一个箭头指向资源本身），我们将其视为不同的类型，如图4.4所示。

<small>图4.4 一个Employee资源指向其他Employee资源代表其经理和助理</small>
![](https://raw.githubusercontent.com/evan-ysj/APIDesignPatternsChinese/main/public/images/4.4.png)

也许你会想知道为什么一个资源会指向与其自身相同类型的另一个资源。这是一个合理的问题，但实际上这种类型的关系出现的频率远远超出你的预期。自引用在层级结构中经常出现，在这种关系中，资源是树中的一个节点，或者在网络式API中，数据可以表示为有向图（例如社交网络）。

例如，想象一个用于存储公司目录的API。在这种情况下，员工相互指向以跟踪彼此的报告关系（例如，员工1向员工2报告）。该API还可能具有进一步的自引用，用于特殊关系（例如，员工1的助手是员工2）。在这些情况中，我们可以使用自引用来建模资源布局。

**层级结构**

最后，我们需要讨论一种非常特殊的关系，这是对标准引用关系的另一种理解：层级结构（hierarchies）。层级结构有点像一个资源指向另一个资源，但该指针通常指向上方，并且意味着不止一个资源指向另一个资源。与典型的引用关系不同，层级结构还倾向于反映资源之间的包含或所有权关系，可能最好使用计算机上的文件夹术语来解释。计算机上的文件夹（对于Linux用户来说是目录）包含许多文件，从这个意义上说，这些文件属于文件夹。文件夹还可以包含其他文件夹，有时会无限循环。

这可能看起来无害，但这种特殊的关系暗示了一些重要的属性和行为。例如，当你在计算机上删除一个文件夹时，通常所有包含在内的文件（和其他文件夹）也会被删除。或者，如果你被授予对特定文件夹的访问权限，这通常意味着对其中的文件（和其他文件夹）也有访问权限。这些相同的行为已经成为类似资源的预期行为。

在我们深入讨论之前，让我们看看层级结构是什么样子。实际上，在前几章中我们已经使用了层级结构的例子，因此我们不应该感到惊讶。例如，我们已经讨论过由许多消息资源组成的ChatRoom资源。在这种情况下，存在ChatRooms包含或拥有Messages的隐含层级关系，如图4.5所示。

<small>图4.5 ChatRoom资源与Message资源的层级关系表明了一种从属关系</small>
![](https://raw.githubusercontent.com/evan-ysj/APIDesignPatternsChinese/main/public/images/4.5.png)

正如你可以想象到，这种结构通常暗示着有权限访问ChatRoom资源也将获得Message资源的访问权限。此外，通常假定删除ChatRoom资源会根据父子层级关系级联到Message资源。在某些情况下，这种级联效应是巨大的好处（例如，我们很高兴能够在计算机上删除整个文件夹，而不必首先删除里面的每个单独文件）。在其他情况下，级联行为可能会非常棘手（例如，我们可能认为我们正在授予对文件夹的访问权限，而实际上我们正在授予对该文件夹内所有文件的访问权限，包括子文件夹）。

总体而言，层级结构是复杂的，会引发许多棘手的问题。例如，资源可以更改父级吗？换句话说，我们可以将Message资源从一个ChatRoom资源移动到另一个ChatRoom资源吗？（通常，这是个坏主意）我们将在第4.2节中更深入地探讨层级结构及其缺点和优势。

### 4.1.2 实体关系图

在本章中，你可能已经看到了一些有趣的符号，它们出现在连接不同资源的线的末端。虽然我们没有时间深入研究[UML](https://en.wikipedia.org/wiki/Unified_Modeling_Language)（统一建模语言），但我们至少可以看一下其中一些箭头并解释它们的工作原理。

简而言之，相比于使用任意箭头从一个资源指向另一个资源，我们可以使箭头末端传达有关资源关系的重要信息。更具体地说，每个箭头末端可以告诉我们在另一端可能有多少资源。例如，图4.6显示学校有很多学生，但每个学生只上一所学校。此外，每个学生上很多课，每个班级包含很多学生。

<small>图4.6 展示学校，学生和课程的实体关系图示例</small>
![](https://raw.githubusercontent.com/evan-ysj/APIDesignPatternsChinese/main/public/images/4.6.png)

虽然这两个符号显然是最常见的，但你可能偶尔会看到其他符号。这是为了涵盖资源数量为零的特殊情况（非必需资源）。例如，从技术上讲，一个班级可能由零个学生组成（反之亦然）。因此真实关系可能看起来更像图4.7。

<small>图4.7 更新后的关系图表明一个学生可能不会参加任何课程，以及一门课程可能并没有学生选择</small>
![](https://raw.githubusercontent.com/evan-ysj/APIDesignPatternsChinese/main/public/images/4.7.png)

有时候理解这种类型的符号可能有点困难，因此澄清应该如何阅读每个连接器的方向可能有所帮助。阅读这些图表的最佳方法是从一个资源开始，沿着线走，然后查看线末端的连接器，最后到达另一个资源。重要的是要记住，您会跳过触及您起始资源的连接器符号。为了更清晰，图4.8显示了学校和学生资源之间的连接分成两个单独的图表，连接的方向写在线旁边。

<small>图4.8 通过学校和学生资源说明如何阅读实体关系</small>
![](https://raw.githubusercontent.com/evan-ysj/APIDesignPatternsChinese/main/public/images/4.8.png)

正如我们所看到的，一个学校有很多学生，而学生只有一个学校。为简单起见，我们将这两者合并到一个单独的图表和一条连接两者的线中，就像我们在之前的示例中看到的那样。

现在我们已经很好地掌握了如何阅读这些图表的方法，让我们开始更重要的工作，即通过选择资源之间的正确关系来建模我们的API。

## 4.2 选择正确的资源关系

正如我们在第4.1节中所学的，选择正确类型的资源关系通常取决于我们首先选择的资源，因此我们将在本节中将这两者联系在一起。让我们首先看一个重要的问题：我们是否需要资源关系？

### 4.2.1 你是否真的需要某种资源关系？

在构建API时，选择了对我们重要的事物或资源之后，下一步是决定这些资源之间的关系。通常人们会像规范化数据库模式一样连接所有可能需要连接的东西，以构建一个丰富的、互相关联的资源网络（通过各种指针和引用）。虽然这肯定会导致一个非常丰富和具有描述性的API，但随着API接收越来越多的流量并存储越来越多的数据，这也变得难以维持，并且可能出现严重的性能下降。

为了理解我们的意思，让我们想象一个简单的API，用户可以在其中关注彼此（例如，类似Instagram或Twitter的东西）。在这种情况下，User资源具有一个多对多的自引用，其中一个用户关注许多其他用户，每个用户可能有许多关注者，如图4.9所示。

<small>图4.9 一个自引用的User资源，表示用户可以关注其他用户</small>
![](https://raw.githubusercontent.com/evan-ysj/APIDesignPatternsChinese/main/public/images/4.9.png)

这可能看起来是无害的，但当用户拥有数百万个关注者（并且用户关注数百万其他用户）时，情况可能变得相当混乱，因为这些类型的关系会导致对单一资源的更改影响数百万其他相关资源的情况。例如，如果某个著名人物删除其Instagram帐户，可能需要删除或更新数百万条记录（取决于底层数据库模式）。

这并不是说您应该以任何代价都要避免所有资源关系。相反，重要的是要在早期权衡任何给定关系的长期成本。换句话说，资源布局（和关系）并不总是没有成本的。就像在签署文件之前了解您的抵押贷款可能会具体花费多少钱一样重要，同样在设计过程中了解给定API设计的真实成本也很重要，而不是在设计的最后阶段了解。尽管在真正需要维护资源关系的场景中（例如前面的例子，存储关注者关系似乎非常重要）总会有办法缓解性能下降的问题，但谨慎定义API中的引用关系仍然是明智的。

换句话说，引用关系应该是有目的的，并且对于期望的行为而言是基本的。换句话说，这些关系永远不应该是偶然发生的、可选的，或者未来可能会需要的东西。相反，任何引用关系都应该是API实现其主要目标所必不可少的东西。

例如，像Twitter、Facebook和Instagram这样的服务是建立在用户相互关注的关系基础上的。用户之间的自引用关系对于这些服务的目标确实是至关重要的。毕竟，没有这种关系，Instagram将变成一个简单的照片存储应用程序。将其与直接消息服务进行比较：我们可以看到，尽管这种API在用户之间以聊天形式表现出某种关系，但它们对应用程序的重要性并不相同。例如，在聊天中涉及的两个用户之间建立关系很重要，但没有必要对所有潜在关系建立一个集合。

### 4.2.2 引用数据还是內联数据

### 4.2.3 层级结构

## 4.3 反模式

### 4.3.1 万物皆资源

### 4.3.2 深层结构

### 4.3.3 內联一切

## 4.4 练习

## 本章总结