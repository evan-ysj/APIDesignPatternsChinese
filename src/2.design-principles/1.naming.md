# 第三章 命名

> 本章涵盖：
> - 为什么我们应该关心命名
> - 如何使命名更合理
> - 如何在语言、语法和句法方面做出选择
> - 上下文如何影响名称的含义
> - 糟糕命名的案例研究

不管我们是否喜欢，名称无处不在。在我们构建的每个软件系统和设计或使用的每个API中，都有名称潜伏在每个角落，它们将存在比我们预计更长的时间。因此，选择好的名称是重要的（尽管我们并不总是认真考虑我们的命名选择）。在本章中，我们将探讨API的不同组件的命名，一些选择良好名称的策略，将好名称与差名称区分开的高级属性，以及在不可避免地做出困难的命名决策时指导我们的一些一般原则。

## 3.1 为什么名称很重要

在软件工程的世界中，几乎不可能避免为事物选择名称。即便我们只需要编写使用语言关键字（例如class，for或if）的代码块，这在最好的情况下也是难以阅读的。考虑到这一点，编译软件是一个特例。这是因为在传统的编译代码中，我们的函数和变量的名称只对那些可以访问源代码的人是有意义的，因为名称本身通常在编译（或压缩）和部署过程中消失。

另一方面，当设计和构建API时，我们选择的名称更加重要，因为它们是API的所有用户将看到和与之交互的内容。换句话说，这些名称不会简单地被编译隐藏，而是对外可见。这意味着我们需要对我们为API选择的名称进行非常多的思考。

显而易见的问题是：“如果发现糟糕的命名，我们不能更改名称吗？”正如我们将在第24章中学到的，更改API中的名称可能非常具有挑战性。想象一下更改源代码中频繁使用的函数的名称，然后意识到您需要进行大量的查找和替换，以确保您更新了对该函数名称的所有引用。尽管这可能有点不方便（在某些IDE中可以很容易），但这当然是可能的。但是，请考虑如果此源代码可供公众构建到其自己的项目中。即使您可以以某种方式更新所有公共源代码的所有引用，始终会有您无法访问并且因此无法更新的私有源代码。

换句话说，在API中更改面向公众的名称有点像更改您的地址或电话号码。要成功地在所有地方更改此数字，您必须与曾经拥有您电话号码的每个人联系，包括使用纸质地址簿的祖母和曾经访问它的每个营销公司。即使您有一种方法与拥有您号码的每个人联系，您仍然需要他们做更新联系信息的工作，而这可能是他们太忙无法完成的工作。

既然我们已经看到选择好的名称（并避免更改它们）的重要性，这引出了一个重要的问题：什么是一个“好”名称呢？

## 3.2 什么是“好”的名称

正如我们在第1章中学到的那样，好的API需要表达能力强，简单且可预测。而名称则非常相似，只是它们不一定是“可操作的”（换句话说，名称实际上并不执行任何操作）。让我们分别看看这些属性以及一些命名选择的示例。首先是表达性。

### 3.2.1 表达性

比任何其他方面都重要的是，名称必须清晰地传达其命名的事物。这个事物可能是一个函数或RPC（例如，`CreateAccount`），一个资源或消息（例如，`WeatherReading`），一个字段或属性（例如，`postal_address`），或者完全不同的东西，比如一个枚举值（例如，`Color.BLUE`），但读者应该清楚地知道这个事物代表着什么。这可能听起来很容易，但是对于不了解在特定领域中上下文的人，就显得比较困难了。这种上下文通常是一个巨大的优势，但在这种情况下更像是一种负担：它使我们在命名事物时表现糟糕。

例如，术语“topic”在异步消息传递的上下文中经常被使用（例如，Apache Kafka或RabbitMQ）；然而，它在机器学习和自然语言处理的一个特定领域中也被使用（topic modeling）。如果你在你的机器学习API中使用术语“topic”，用户可能会对你指的是哪一种类型的主题（topic）感到困惑，这并不奇怪。如果这是一个真实的用例（也许你的API既使用异步消息传递，又使用主题建模），你可能希望选择一个比“topic”更有表达力的名称，比如“model_topic”或“messaging_topic”，以防止用户混淆。

### 3.2.2 简洁性

虽然有表达力的名称当然很重要，但如果名称过长而没有增加额外的清晰度，它也可能变得繁琐。使用之前的例子（“topic”在计算机科学的多个不同领域中使用），如果一个API只涉及异步消息传递（例如，类似于Apache Kafka的API），与机器学习无关，那么“topic”已经足够清晰和简单，而“messaging_topic”就不会增加太多价值。简而言之，名称应该具有表达力，但只有在名称的每个附加部分都增加了价值以证明其存在的合理性时才能具有表达力。

另一方面，名称也不应过于简化。例如，想象一下我们有一个需要存储一些用户指定偏好的API。资源可能被称为“UserSpecifiedPreferences”；然而，“Specified”并没有为名称增添太多内涵。另一方面，如果我们简单地将资源命名为“Preferences”，那么这是不清楚是谁的偏好，并且在以后需要存储和管理系统或管理员级偏好时可能会引起混淆。在这种情况下，“UserPreferences”似乎是具有表达力和简单之间的平衡点，总结在表3.1中。

<small>表3.1 在表达性和简洁性之间选择</small>

| 名称 | 说明 |
| --- | --- |
| `UserSpecifiedPreferences` | 具有表达力，但不够简洁 |
| `UserPreferences` | 简洁，并有足够的表达性 |
| `Preferences` | 过于简洁 |

### 3.2.3 可预测性

现在我们已经讨论了表达性和简洁性之间的平衡，还有一个非常重要的方面：可预测性。想象一个API使用名称“topic”将类似的异步消息组合在一起（类似于Apache Kafka）。然后该API在其他地方使用名称“messaging_topic”而不是“topic”，这将导致一些非常令人沮丧和不寻常的情况。

<small>代码3.1 不一致的命名示例</small>
```typescript
function handleMessage(message: Message) {
    // 这里我们使用`topic`读取给定消息的主题
    if (message.topic == "budget.purge") {
        client.PurgeTopic({
            // 这里我们使用了`messagingTopic`来表示相同的概念
            messagingTopic: "budget.update"
        });
    }
}
```

在这种情况下，且不考虑是否会导致用户困扰，请考虑我们可能违反的一个重要原则。通常情况下，我们应该使用相同的名称表示相同的事物，使用不同的名称表示不同的事物。如果我们将这个原则看作是公理，这就引出了一个重要的问题：“topic”与“messagingTopic”有何不同？毕竟，我们使用了不同的名称，所以它们必须代表不同的概念，对吧？

通常一个基本的目标是允许API的用户学习一个名称，并继续在此基础上构建知识，以便能够预测未来的名称（例如，如果它们代表相同的概念）会是什么样子。通过在API中一致使用“topic”来表示“给定消息的主题”（以及在表示不同概念时使用其他名称），我们允许API的用户基于他们已经学到的知识去构建应用，而不是混淆这些名称，并迫使用户研究每个名称以确保它的含义与他们的假设相符。

现在我们对好的名称的一些特征有了了解，让我们继续探讨在API中命名事物时可以作为防护栏的一般指导原则。首先从语言、语法和句法开始。

## 3.3 语言，语法与句法

### 3.3.1 语言

### 3.3.2 语法

### 3.3.3 句法

## 3.4 上下文

## 3.5 数据类型和单位

## 3.6 糟糕命名的案例研究

## 3.7 练习

## 本章总结